# Сначала импортируем необходимые библиотеки, 
# загрузим датасет (используем знакомый нам датасет о диабете) 
# и создадим переменную random_row, значение которой будет соответствовать случайному числу от  0 до N-1, где  N — количество объектов в выборке.

import pika
import numpy as np
import json
from sklearn.datasets import load_diabetes

# Для тестирования наших микросервисов, в том числе скрипта features.py, давайте зафиксируем датчик случайных чисел:
np.random.seed(42)


# Загружаем датасет о диабете
X, y = load_diabetes(return_X_y=True)
# Формируем случайный индекс строки
random_row = np.random.randint(0, X.shape[0]-1)


# Таким образом, в нашем скрипте можно будет получить случайный вектор признаков X[random_row] и истинный ответ для него — y[random_row].

# Давайте подключимся к брокеру и попробуем отправлять в очередь y_true случайную метку y[random_row]. 
# Для организации соединения следует создать объект BlockingConnection. 
# В его инициализатор необходимо передать объект с параметрами организуемого соединения — ConnectionParameters. 
# Наши сервисы будут взаимодействовать через localhost. После того как мы создали объект соединения, необходимо создать канал, по которому сервисы будут обмениваться данными.
# Итоговый код для создания подключения к серверу брокера будет выглядеть так:

# Подключение к серверу на локальном хосте:
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()


# Далее объявим в канале соединения очередь сообщений с помощью метода queue_declare(). Назовём очередь "y_true" (параметр queue).
# Создаём очередь y_true
channel.queue_declare(queue='y_true')

# Если при выполнении скрипта очередь на брокере ещё не была создана, то она будет создана, иначе мы будем работать с уже имеющейся очередью.
# Далее наш микросервис должен отправить сообщение в очередь. Для этого используется метод basic_publish(). В нём необходимо указать следующие параметры:

# o	exchange — определяет, в какую очередь отправляется сообщение.
# Как мы знаем, в RabbitMQ сообщения не отправляются сразу в очередь, а проходят через точку обмена (exchange). Сейчас нам достаточно знать, что точку обмена по умолчанию можно определить, указав пустую строку.

# o	routing_key — указывает имя очереди.
# o	body — тело самого сообщения, которое мы хотим поместить в очередь.

# Публикуем сообщение
channel.basic_publish(exchange='',
                      routing_key='y_true',
                      body=json.dumps(y[random_row]))
print('Сообщение с правильным ответом отправлено в очередь')

# Добавим ещё одну очередь — features. В неё мы будем отправлять признаки, соответствующие случайно выбранному объекту из данных:
# Создаём очередь features
channel.queue_declare(queue='features')

# Публикуем сообщение
channel.basic_publish(exchange='',
                      routing_key='features',
                      body=json.dumps(list(X[random_row])))
print('Сообщение с вектором признаков отправлено в очередь')

# После отправки сообщения мы должны закрыть подключение с помощью метода close().
# Закрываем подключение 
connection.close()


