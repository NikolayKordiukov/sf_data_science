# Приступим к написанию второго сервиса — он прочитает признаки из очереди features, сделает предсказание и отправит его в очередь y_pred.

# Создадим второй файл model.py и добавим в него необходимые импорты:

import pika
import pickle
import numpy as np
import json
# Ранее мы уже создавали модель для решения поставленной задачи регрессии. Давайте возьмём наш файл с обученной моделью:

with open('myfile.pkl', 'rb') as pkl_file:
    regressor = pickle.load(pkl_file)

# Подключимся к серверу:
connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))
channel = connection.channel()


# Укажем, с какой очередью будем работать:

channel.queue_declare(queue='features')
# Напишем функцию callback(), определяющую, как работать с полученным сообщением. 
# Эта функция в дальнейшем будет передана для обработки очереди, поэтому у неё должен быть шаблонный синтаксис: стандартные аргументы ch, method, properties и body. 
# В данный момент нас интересует только аргумент body — тело сообщения из очереди. 
# Наша функция-обработчик будет просто выводить на экран сообщение из очереди features (вектор признаков).


# Объявляем очередь y_pred
channel.queue_declare(queue='y_pred')

# Создаём функцию callback для обработки данных из очереди y_pred
def callback(ch, method, properties, body):
    print(f'Получен вектор признаков {body}')
    features = json.loads(body)
    pred = regressor.predict(np.array(features).reshape(1, -1))
    channel.basic_publish(exchange='',
                      routing_key='y_pred',
                      body=json.dumps(pred[0]))
    print(f'Предсказание {pred[0]} отправлено в очередь y_pred')
    
# На следующем шаге микросервис должен будет извлечь сообщение из очереди features с помощью метода basic_consume(). В аргументах данного метода укажем:

# queue — имя очереди;
# on_message_callback — функцию-обработчик очереди, которая устанавливает, какие действия должны быть произведены с полученным из очереди сообщением;
# auto_ack — параметр, определяющий, использовать ли режим автоматического подтверждения (подробнее об этом — здесь).

# Извлекаем сообщение из очереди features
# on_message_callback показывает, какую функцию вызвать при получении сообщения
channel.basic_consume(
    queue='features',
    on_message_callback=callback,
    auto_ack=True
)
print('...Ожидание сообщений, для выхода нажмите CTRL+C')

# Мы указали все параметры, необходимые для работы микросервиса. 
# Осталось запустить его в режиме ожидания прихода сообщений. Для этого используется метод start_consuming(). Скрипт будет работать до принудительной остановки (CTRL+C) — так мы не пропустим ни одного сообщения.

# Запускаем режим ожидания прихода сообщений
channel.start_consuming()
# Важно! Обратите внимание, что после того как сообщение будет получено из очереди и обработано функцией-обработчиком, оно удаляется по правилам очереди.