# Если бы вы попробовали написать сервер в Jupyter Notebook, то почти сразу поняли бы, что он для этого не предназначен. 
# Как минимум потому, что после запуска вы больше не смогли бы выполнить в ноутбуке ни одной команды — программа сервера переходит в режим прослушки сети и ожидания приходящих запросов. 
# Поэтому разработку нашего веб-сервиса мы будем вести в обычных файлах .py.

# Итак, давайте напишем простое приложение на Flask.

# ЧАСТЬ I. ИНИЦИАЛИЗАЦИЯ ВЕБ-ПРИЛОЖЕНИЯ

# импортируем Flask и создадим объект Flask-приложения.
# from flask import Flask
# app = Flask(__name__)


# Мы передаём __name__ при инициализации класса Flask, чтобы определить имя, с которым будет использоваться этот модуль. 
# Flask использует расположение файла как точку, к которой он привязывает ресурсы.

# Совет. В абсолютном большинстве случаев можно передавать аргумент __name__ для инициализации класса — приложение будет настроено верно.

# Теперь мы можем написать функцию, которая будет обрабатывать запросы, и прикрепить её к какому-то пути (URI). Это делается с помощью специального декоратора route.
# @app.route('/hello')
# def hello_func():
#     return 'hello!'

# Наша функция пока не делает никакой обработки и просто отвечает строкой с приветствием. Нам осталось запустить приложение. Для этого выполним метод run, не забыв занести его в стандартный main.
# if __name__ == '__main__':
#     app.run('localhost', 5000)
    
# Примечание. В блоке if __name__ == '__main__' прописывается код, который не должен выполняться при импорте модуля. 
# Переменная __name__ — это специальная переменная, которая будет равна "__main__", только если файл запускается как основная программа, и выставляется равной имени модуля при импорте модуля.

# Например, если мы захотим импортировать файл server.py как внешний модуль,
# from server import *
# то код, указанный в блоке if __name__ == '__main__', соответствующий запуску сервера, не будет выполнен.

# Мы запускаем наш сервис в строке app.run('localhost', 5000), указывая адрес сетевого интерфейса и порт, на котором будет работать сервер. 
# В нашем случае мы работаем на локальной машине по IP-адресу 127.0.0.1, или localhost (то есть доступ к сервису может быть получен только с нашего компьютера), а номер порта, по которому можно отправлять запросы, — 5000.

# Если вы работаете в Jupyter Notebook, сохраните весь код в файле server.py (не в ноутбуке!) и запустите его из командной строки, выполнив команду python server.py.
# Вы должны увидеть примерно такой текст:

# * Serving Flask app "server" (lazy loading)
# * Environment: production
#    WARNING: This is a development server. Do not use it in a production deployment.
#    Use a production WSGI server instead.
# * Debug mode: off
# * Running on http://localhost:5000/ (Press CTRL+C to quit)#

# После запуска программа перейдёт в режим прослушивания сети.
# Теперь откройте браузер и зайдите по адресу http://localhost:5000/hello.
# Вы увидите текст hello!, а в логах — строку с кодом обработки вашего запроса.
# Примечание. Чтобы прервать работу программы-сервера в VS Code, нажмите сочетание клавиш CTRL + C, находясь в поле терминала. После этого перезапустите скрипт.

# Напишите новую функцию index(), которая будет возвращать строку "Test message. The server is running". 
# Оберните эту функцию в декоратор app.route(), указав в качестве эндпоинта '/'. Данный эндпоинт будет соответствовать обращению к сайту по дефолтному адресу: http://localhost:5000/.
# Перезапустите веб-сервис и зайдите по этому адресу. В поле для ответа введите код обработки, который вернулся в результате выполнения GET-запроса.

# @app.route('/')
# def index():
#     return "Test message. The server is running"

# Давайте немного усложним логику обработки — создадим функцию, которая принимает какой-то параметр и использует его для вычисления результата.

# Параметры можно передавать тремя способами:

# через адресную строку;
# через заголовки;
# через тело.
# В заголовках обычно передают сервисные параметры. Так как у метода GET не бывает тела, остаются только параметры адресной строки.

# Вы наверняка видели параметры на сайтах, когда в конец адреса дописывается что-то вроде ?id=10&page=2. 
# Если поставить в конце адреса вопросительный знак, то после него можно добавлять параметры. Передавать можно любые параметры — они будут перечисляться через & и состоять из имени и значения (id=10). 
# Например, если вы будете что-то искать в Google, ваш запрос будет видно в адресной строке в параметре с названием q (от англ. query).

# Параметры запроса во Flask находятся в специальном объекте request, который нужно импортировать. Параметры адресной строки можно найти в поле args этого объекта, где args — это словарь.
# Давайте немного модифицируем наш код — теперь сервер будет здороваться и обращаться по имени. 
# Для этого занесём параметр name, полученный из request, в переменную и воспользуемся этим значением, поставив его в форматированную строку.

# from flask import Flask, request

# app = Flask(__name__)
# @app.route('/hello')

# def hello_func():
#     name = request.args.get('name')
#     return f'hello {name}!'

# if __name__ == '__main__':
#     app.run('localhost', 5000)
    
    
# Перезапустите сервер и зайдите по адресу http://localhost:5000/hello?name=world.

# В результате выполнения запроса вы должны увидеть в браузере текст "hello world".

# Поменяйте значение параметра name в адресной строке на своё имя и выполните новый запрос к серверу, чтобы проверить, что при изменении параметра адресной строки меняется и возвращаемый результат.

# Напишите функцию current_time, которая будет возвращать словарь, где ключ — 'time', а значение — текущее время.

# Примечание. Текущее время можно узнать с помощью модуля datetime:

# import datetime
# now = datetime.datetime.now()
# Оберните эту функцию в декоратор app.route() с эндпоинтом /time.

# Попробуйте обратиться к сервису по заданному эндпоинту.

# По какой ссылке вы переходили, чтобы увидеть, правильно ли работает ваш скрипт? В поле ниже вставьте ссылку.
# http://localhost:5000/time


# from flask import Flask, request
# import datetime


# app = Flask(__name__)
# @app.route('/hello')
# def hello_func():
#     name = request.args.get('name')
#     return f'hello {name}!'

# @app.route('/')
# def index():
#     return "Test message. The server is running"


# @app.route('/time')
# def current_time():
#     now = datetime.datetime.now()
#     return {'time':now}


# if __name__ == '__main__':
#     app.run('localhost', 5000)

# ЧАСТЬ III. POST-ЗАПРОСЫ

# Пока что мы написали обработчик GET-запроса.

# Если мы хотим обрабатывать и другие методы, например POST-запросы, это необходимо указать в декораторе:

# @app.route('/add', methods=['POST'])
# Что должна возвращать функция-обработчик? 
# Она будет возвращать объект Response, в котором мы должны были бы задать все компоненты ответа: код обработки, заголовки и тело. 
# К счастью, Flask (а точнее, объект Response) умеет и превращать в ответы другие объекты, и самостоятельно формировать ответ.

# Например, строка
# return f'hello {name}!'

# преобразуется в ответ с кодом 200 и телом, состоящим из этой строки:
# return f'hello {name}!', 200

# Также можно возвращать кортеж из двух элементов, строки и числа. Число используется как код обработки.

# Примечание. Вспомогательная функция jsonify поможет преобразовать обычный питоновский словарь в ответ в формате JSON, который очень часто используется для передачи структурированных данных.

# Вооружившись этими знаниями, напишем обработчик POST-запроса, который будет читать тело запроса в JSON-формате и составлять ответ на основе его содержимого.

# from flask import Flask, request, jsonify

# app = Flask(__name__)
# Укажем, что функция обрабатывает метод POST:

# @app.route('/add', methods=['POST'])
# Напишем саму функцию:

# def add():
#     num = request.json.get('num')
# Параметры тела доступны в поле data. Но если тело — это JSON-строка, то можно использовать поле json.

# Напишем проверку и укажем код ошибки:

#     if num > 10:
#         return 'too much', 400
#     return jsonify({
#         'result': num + 1})

# Тогда функция-обработчик будет иметь следующий вид:
# @app.route('/add', methods=['POST'])
# def add():
#     num = request.json.get('num')
#     if num > 10:
#         return 'too much', 400
#     return jsonify({
#         'result': num + 1})

# Запускаем:
# if __name__ == '__main__':
#     app.run('localhost', 5000)


# from flask import Flask, request, jsonify
# import datetime


# app = Flask(__name__)
# @app.route('/hello')
# def hello_func():
#     name = request.args.get('name')
#     return f'hello {name}!'

# @app.route('/')
# def index():
#     return "Test message. The server is running"


# @app.route('/time')
# def current_time():
#     now = datetime.datetime.now()
#     return {'time':now}

# @app.route('/add', methods=['POST'])
# def add():
#     num = request.json.get('num')
#     if num > 10:
#         return 'too much', 400
#     return jsonify({'result': num + 1})


# if __name__ == '__main__':
#     app.run('localhost', 5000)
    
    
# К сожалению, браузеры не умеют писать POST-запросы самостоятельно. Это реализуется только через клиентские приложения, поэтому нам не хватит обычного браузера, чтобы проверить сервис.

# Если вы любите визуальные редакторы запросов, рекомендуем обратить внимание на Postman.

# Напишем простой сервис в соседнем скрипте, используя библиотеку requests, которая позволяет отправлять HTTP-запросы. Для этого создадим отдельный файл client.py, в котором опишем работу программы клиента.

# Чтобы выполнить POST-запрос, нужно просто вызвать соответствующую функцию и передать ей адрес (URL) и содержимое тела запроса.


# ДЕПЛОИМ МОДЕЛЬ НА ВЕБ-СЕРВИС

# Итак, мы рассмотрели базовые принципы работы с фреймворком Flask и научились писать простейшие веб-сервисы. Этого достаточно, чтобы решить нашу первоначальную задачу — задеплоить модель.
# Нам необходимо написать веб-сервис, который позволит клиентам делать запросы к нашей модели. В ответ клиенты должны получать ответы — предсказания модели. Формат предсказаний обсудим ниже.
# У модели, как всегда, есть метод predict, который принимает на вход numpy-массив размерности (кол-во объектов; кол-во признаков). Всего у нас четыре анонимных признака, и их интерпретация сейчас не имеет значения.

# Давайте обернём процедуру предсказания модели в обработчик POST-запросов.
# Используя только что обретённые знания, напишите Flask-приложение, которое по эндпоинту /predict будет слушать POST-запросы на предсказания.
# В теле POST-запроса — список из четырёх чисел в формате JSON (один объект, четыре признака). Эти числа можно извлечь из запроса следующим образом:
# features = request.json

# Так как на вход модели необходимо подать numpy-массив определённой размерности, а не список, не забудьте перевести результат в тип np.array() и скорректировать его под размер (1, 4) с помощью reshape():
# features = np.array(features).reshape(1, 4) 
# После этого подайте полученный вектор на вход модели и получите результат.
# Обратите внимание, что результатом предсказания также станет не число, а numpy-массив, пусть и состоящий из одного числа. Нас же интересует именно предсказанное число, поэтому не забудьте извлечь результат из полученного массива (обратившись по индексу 0).
# Ответом на запрос должен быть JSON-формат {"prediction": *число - предсказание модели*}.


from flask import Flask, request, jsonify
import datetime
import pickle
import numpy as np

with open('C:\\Users\\пользователь\\Desktop\\IDE\DS_PROD_1\\model_to_deploy.pkl', 'rb') as pkl_file:
    model = pickle.load(pkl_file)

app = Flask(__name__)
@app.route('/hello')
def hello_func():
    name = request.args.get('name')
    return f'hello {name}!'

@app.route('/')
def index():
    return "Test message. The server is running"


@app.route('/time')
def current_time():
    now = datetime.datetime.now()
    return {'time':now}

@app.route('/add', methods=['POST'])
def add():
    num = request.json.get('num')
    if num > 10:
        return 'too much', 400
    return jsonify({'result': num + 1})

@app.route('/predict', methods=['POST'])
def predict():
    features = np.array(request.json)
    features = features.reshape(1, 4)
    prediction = model.predict(features)
    return  jsonify({'prediction': prediction[0]})


if __name__ == '__main__':
    app.run('localhost', 5000)
    
#     PS C:\Users\пользователь\Desktop\IDE> & C:/Users/пользователь/AppData/Local/Programs/Python/Python39/python.exe c:/Users/пользователь/Desktop/IDE/DS_PROD_1/server.py
# C:\Users\пользователь\AppData\Local\Programs\Python\Python39\lib\site-packages\sklearn\base.py:318: UserWarning: Trying to unpickle estimator LinearRegression from version 1.0.2 when using version 1.2.2. This might lead to breaking code or invalid results. Use at your own risk. For more info please refer to:
# https://scikit-learn.org/stable/model_persistence.html#security-maintainability-limitations
#   warnings.warn(
# secret word: skillfactory
# how is this possible? answer is here: https://youtu.be/xm-A-h9QkXg
#  * Serving Flask app 'server'
#  * Debug mode: off
# WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
#  * Running on http://localhost:5000
# Press CTRL+C to quit

# в другом терминале
# PS C:\Users\пользователь\Desktop\IDE> python C:\Users\пользователь\Desktop\IDE\DS_PROD_1\hw2_check_ol.py
# ('secret code3:', '3298f')
# PS C:\Users\пользователь\Desktop\IDE> 